<html>
<title>Timer Video Generator</title>
<body>
<h1>Timer Video Generator (WebP Animation)</h1>

<form>
<label for="font">Font:</label>
<select name="font" id="font">
  <option value="Andale Mono">Andale Mono</option>
  <option value="Arial Black">Arial Black</option>
  <option value="Baskerville">Baskerville</option>
  <option value="Bradley Hand">Bradley Hand</option>
  <option value="Brush Script MT">Brush Script MT</option>
  <option value="Comic Sans MS">Comic Sans MS</option>
  <option value="Courier">Courier</option>
  <option value="Georgia">Georgia</option>
  <option value="Gill Sans">Gill Sans</option>
  <option value="Helvetica" selected>Helvetica</option>
  <option value="Impact">Impact</option>
  <option value="Lucida">Lucida</option>
  <option value="Luminari">Luminari</option>
  <option value="Monaco">Monaco</option>
  <option value="Palatino">Palatino</option>
  <option value="Tahoma">Tahoma</option>
  <option value="Times New Roman">Times New Roman</option>
  <option value="Trebuchet MS">Trebuchet MS</option>
  <option value="Verdana">Verdana</option>
</select>

<label for="size">Size:</label>
<input type="number" id="size" min="4" max="400" value="30"/>
<br/>
<label for="start">Start:</label>
<input type="text" id="start" value="00:00"/>
<br/>
<label for="end">End:</label>
<input type="text" id="end" value="01:00"/>
<br/>
<input type="checkbox" id="tenths" checked/>
<label for="tenths">Show tenths of a second</id>
<br/>
Text: 
<label for="textR">Red</label> <input id = "textR" type="number" min="0" max="255" value="0"/>
<label for="textG">Green</label> <input id = "textG" type="number" min="0" max="255" value="0"/>
<label for="textB">Blue</label> <input id = "textB" type="number" min="0" max="255" value="128"/>
<label for="textA">Opacity</label> <input id = "textA" type="number" min="0" max="1" value="1" step="0.05"/>
<br/>
Back: 
<label for="backR">Red</label> <input id = "backR" type="number" min="0" max="255" value="0"/>
<label for="backG">Green</label> <input id = "backG" type="number" min="0" max="255" value="0"/>
<label for="backB">Blue</label> <input id = "backB" type="number" min="0" max="255" value="0"/>
<label for="backA">Opacity</label> <input id = "backA" type="number" min="0" max="1" value="0.5" step="0.05"/>
<br/>

<label for="margin">Margin fraction:</id>
<input type="number" min="0" max="2" value="0.1" step="0.05" id="margin"/>
<br/>
<select name="align" id="align">
  <option value="left">Left</option>
  <option value="right">Right</option>
  <option value="center" selected>Center</option>
</select>
<br/>
<label for="line0">Line 1:</label>
<select name="line0" id="line0" onchange="changedLineOption(0)">
  <option value="static">Static text</option>
  <option value="timer" selected>Timer</option>
  <option value="timedtext">Timed text</option>
</select>
<br/>
<input type="text" id="static0" value="" placeholder="Static text" hidden="true"/>
<textarea id="timed0" name="text" rows="10" cols="60" placeholder="00:00 Start" hidden="true"></textarea>
<br/>
<label for="line1">Line 2:</label>
<select name="line1" id="line1" onchange="changedLineOption(1)">
  <option value="none" selected>None</option>
  <option value="static">Static text</option>
  <option value="timer">Timer</option>
  <option value="timedtext">Timed text</option>
</select>
<br/>
<input type="text" id="static1" value="" placeholder="Static text" hidden="true"/>
<textarea id="timed1" name="text" rows="10" cols="60" placeholder="00:00 Start" hidden="true" ></textarea>
<br/>
<button type="button" disabled="true" id="preview" onClick="run(true);">Preview</button>
<button type="button" disabled="true" id="go" onClick="run(false);">Generate!</button>
<br/>
<button type="button" hidden="true" id="download" onClick="downloadToDisc(output[0],output[1])">Download WebP file</button>
</form>
<br/>
<br/>

<canvas id="myCanvas" width="400" height="200"></canvas>

<script src="https://cdn.jsdelivr.net/gh/sumimakito/webpxmux.js@master/dist/webpxmux.min.js" type="text/javascript"></script>
    

<script>

var output = null;

var xMux = WebPXMux("https://cdn.jsdelivr.net/gh/sumimakito/webpxmux.js@master/dist/webpxmux.wasm");
    xMux.waitRuntime().then(function () {
    enableButtons(true);
    }); 

async function downloadToDisc(header, frames) {
    const opts = {
        types: [{
          description: 'WEBP animation',
          accept: {'image/webp': ['.webp']},
        }],
    };

    const newHandle = await window.showSaveFilePicker(opts);

    const writableStream = await newHandle.createWritable();
    
    await writableStream.write(new Blob([header]));
    
    for (var i = 0 ; i < frames.length ; i++) {
        await writableStream.write(new Blob([frames[i]]));
    }

    await writableStream.close();
}
    
function downloadBlob(name,blob) {
    var link = document.createElement('a');
    document.body.appendChild(link);
    link.download = name;
    link.href = window.URL.createObjectURL(blob);
    link.onclick = function(e) {
        setTimeout(function() {
            window.URL.revokeObjectURL(link.href);
        }, 1600);
    };
    link.click();
    try {
        link.remove();
    }
    catch(err) {}  
    try {
        document.body.removeChild(link);
    }
    catch(err) {}
}

function fix32(data) {
  for (var i=0;i<data.length;i++) {
    // in:abgr??
    r = data[i] & 0xFF;
    g = (data[i]>>8) & 0xFF;
    b = (data[i]>>16) & 0xFF;
    a = (data[i]>>24) & 0xFF;
    // out:rgba
    data[i] = (r<<24)|(g<<16)|(b<<8)|a;
  }
}

function fourCC(s) {
    return s.charCodeAt(0) | (s.charCodeAt(1) << 8) | (s.charCodeAt(2) << 16) | (s.charCodeAt(3) << 24);
}

function read32(data,offset) {
    return data[offset] | (data[offset+1]<<8) | (data[offset+2]<<16) | (data[offset+3]<<24);
}

function roundup(pos) {
    if (pos % 2)
        return pos + 1;
    else
        return pos;
}

function skipChunk(data,offset) {
    return roundup(offset + 8 + read32(data,offset+4));
}

function riffChunk(riffFile,chunkID) {
    length = 8 + read32(riffFile, 4);
    pos = 12;
    while (pos + 8 < length) {
        if (read32(riffFile, pos) == chunkID) {
            chunkLen = read32(riffFile, pos + 4);
            return riffFile.subarray(pos, pos + 8 + chunkLen);
        }
        pos = skipChunk(riffFile,pos);
    }
    return null;
}

async function getVP8(width,height,imageData) {
    fix32(imageData);
    return riffChunk(await xMux.encodeWebP({width:width,height:height,rgba:imageData}), fourCC('VP8 '));
}

function set32(data,offset,value) {
    data[offset] = value;
    data[offset+1] = value >> 8;
    data[offset+2] = value >> 16;
    data[offset+3] = value >> 24;
}

function set24(data,offset,value) {
    data[offset] = value;
    data[offset+1] = value >> 8;
    data[offset+2] = value >> 16;
}

function set16(data,offset,value) {
    data[offset] = value;
    data[offset+1] = value >> 8;
}

function getANMF(width,height,duration,vp8Chunk) {
    length = 24 + vp8Chunk.length;
    data = new Uint8Array(roundup(length));
    set32(data,0,fourCC('ANMF'));
    set32(data,4,length-8);
    set24(data,8,0);  // X
    set24(data,11,0); // Y
    set24(data,14,width-1);
    set24(data,17,height-1);
    set24(data,20,duration);
    data[23] = 0x80|0x40; // disposal:1, blend:1
    for (var i=0;i<vp8Chunk.length; i++)
        data[24+i] = vp8Chunk[i];
    return data;
}

function makeWebpHeader(frameSize,width,height,bgColor) {
    var fileSize = frameSize + 12 /* file header */ + 18 /* VP8X */ + 14 /* ANIM */;
    var webp = new Uint8Array(12 /* file header */ + 18 /* VP8X */ + 14 /* ANIM */);

    set32(webp, 0, fourCC('RIFF'));
    set32(webp, 4, fileSize - 8);
    set32(webp, 8, fourCC('WEBP'));
    pos = 12; // VP8X
    set32(webp, pos, fourCC('VP8X'));
    set32(webp, pos+4, 18-8);
    webp[pos+8] = (0x10*0) /* ALPHA */ | 0x2 /* ANIMATION */;
    set24(webp, pos+8+4, width-1);
    set24(webp, pos+8+4+3, height-1);
    pos += 8 + 4 + 3 + 3;
    set32(webp, pos, fourCC('ANIM'));
    set32(webp, pos+4, 14-8);
    set32(webp, pos+8, bgColor);
    set16(webp, pos+8+4, 1); // loop count
    
    return webp;
}

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function parseTime(s,tenths) {
    var sign = 1;
    if (s[0] == '-') {
        sign = -1;
        s = s.substr(1);
    }
    
    var t = 0;
    var mul = 1;

    var x = s.split(".");
    if (tenths) {
        if (x.length > 1)
            t = parseInt(x[1][0]);
        mul = 10;
    }
    
    var v = x[0].split(":");
    for (var i = v.length - 1 ; i >= 0 ; i--) {
        t += mul * parseInt(v[i]);
        mul *= 60;
    }
    return sign * t;
}

function formatTime(t, tenths) {
    var neg = false;
    if (t<0) {
        neg = true;
        t = -t;
    }
    var decimal = "";
    if (tenths) {
        decimal = "."+(t%10).toString();
        t = (t/10) >> 0;
    }
    s = t % 60;
    m = ( (t / 60) >> 0 );
//    h = (t / 3600) >> 0;
    return (neg ? "-" : "") + m.toString().padStart(2, "0") + ":" + s.toString().padStart(2, "0") + decimal;
}

function parseTimedText(text, tenths) {
  timedText = [];
  lines = text.split(/\r?\n/);
  for (var i = 0 ; i < lines.length ; i++) {
    var line = lines[i].trim();
    if (line) {
        var t = 0;
        var show = "";
        const found = line.match(/([^\s]*)\s+(.*)/);
        if (found) {
            t = parseTime(found[1], tenths);
            show = found[2];
        }
        else {
            t = parseTime(line, tenths);
        }
        timedText.push( { "time": t, "text": show } );
    }
  }
  timedText.sort((a,b) => a.time - b.time);
  return timedText;
}

function getText(t, tenths, lineOptions) {
  if (lineOptions.mode == "none")
    return "";
  else if (lineOptions.mode == "timer")
    return formatTime(t, tenths);
  else if (lineOptions.mode == "static")
    return lineOptions.static;
  var text = "(empty)";
  var timedText = lineOptions.timedText;
  for (var i = 0 ; i < timedText.length ; i++) {
    if (t >= timedText[i].time) 
        text = timedText[i].text;
    else
        break;
  }
  return text;
}

function lineMetrics(line, ctx, start, end, tenths) {
    var texts;
    if (line.mode == "timer") {
        texts = [ formatTime(start, tenths), formatTime(((start+end)/2) >> 0, tenths), formatTime(end, tenths) ];
    }
    else if (line.mode == "static") {
        texts = [ line.static ];
    }
    else if (line.mode == "timedtext") {
        texts = [];
        for (var i = 0 ; i < line.timedText.length ; i++)
            texts.push(line.timedText[i].text);
    }
    var metrics = { width:0, ascent:0, descent:0 };
    for (var i = 0 ; i < texts.length ; i++) {
        var m = ctx.measureText(texts[i]);
        metrics.width = Math.max(m.width, metrics.width);
        metrics.ascent = Math.max(m.actualBoundingBoxAscent, metrics.ascent);
        metrics.descent = Math.max(m.actualBoundingBoxDescent, metrics.descent);
    }
    metrics.height = metrics.ascent + metrics.descent;
    return metrics;
}

function getColor(elt) {
  return "rgba("+
      document.getElementById(elt + "R").value+","+
      document.getElementById(elt + "G").value+","+
      document.getElementById(elt + "B").value+","+
      document.getElementById(elt + "A").value+")";
}

function getColorNum(elt) {
  return 
      Math.floor(document.getElementById(elt + "A").value*255) | 
      (document.getElementById(elt + "B").value<<8)|
      (document.getElementById(elt + "G").value<<16)|
      (document.getElementById(elt + "R").value<<24);
}

async function generate(preview) {
  const tenths = document.getElementById("tenths").checked;
  const frameTime = tenths ? 100 : 1000; // milliseconds
  const align = document.getElementById("align").value;
  
  const fore = getColor("text");
  const back = getColor("back");
  
  var lines = [ {mode:document.getElementById("line0").value}, {mode:document.getElementById("line1").value} ];
  var numLines = lines[1].mode != "none" ? lines.length : 1;
  
  var canvas = document.getElementById("myCanvas");  
  var ctx = canvas.getContext("2d", { willReadFrequently: true });
  var font = ""+document.getElementById("size").value+"px " + document.getElementById("font").value;
  ctx.font = font;
  var start = parseTime(document.getElementById("start").value, tenths);
  var end = parseTime(document.getElementById("end").value, tenths);
  
  for (var i = 0 ; i < numLines ; i++) {
    if (lines[i].mode == "timedtext")
        lines[i].timedText = parseTimedText(document.getElementById("timed"+i).value, tenths);
    else if (lines[i].mode == "static")
        lines[i].static = document.getElementById("static"+i).value;
    lines[i].metrics = lineMetrics(lines[i], ctx, tenths);
  }
  
  var margin;
  var width;
  var height;
  
  var marginFrac = parseFloat(document.getElementById("margin").value);
  
  if (numLines == 1) {
    margin = Math.ceil(marginFrac * lines[0].metrics.height);
    width = 2 * margin + Math.ceil(lines[0].metrics.width);
    height = 2 * margin + Math.ceil(lines[0].metrics.height);
    lines[0].y = Math.floor(height - margin - lines[0].metrics.descent);
  }
  else {
    maxHeight = Math.max(lines[0].metrics.height, lines[1].metrics.height);
    margin = Math.ceil(marginFrac * maxHeight);
    width = 2 * margin + Math.ceil(Math.max(lines[0].metrics.width, lines[1].metrics.width));
    height = 3 * margin + Math.ceil(lines[0].metrics.height) + Math.ceil(lines[1].metrics.height);
    lines[0].y = Math.floor(margin + lines[0].metrics.height - lines[0].metrics.descent);
    lines[1].y = Math.floor(height - margin - lines[1].metrics.descent);
  }
  
  canvas.width = width;
  canvas.height = height;
  ctx = canvas.getContext("2d", { willReadFrequently: true });
  ctx.font = font;

  var buffer;
  var bufferPos
  
  if (! preview) {
    var frames = [];
    var framesLength = 0;
  }
  
  var t = preview ? ((end + start)/2)>>0 : start;
  var i = 0;
  while (t <= end) {
      ctx.fillStyle = back;
      ctx.clearRect(0, 0, width, height);
      ctx.fillRect(0, 0, width, height);
      ctx.fillStyle = fore;
      ctx.font = font;
      for (var j=0; j<numLines; j++) {
        var text = getText(t, tenths, lines[j]);
        if (align == "left") {
            ctx.fillText(text, margin, lines[j].y);
        }
        else {
            var w = ctx.measureText(text).width;
            if (align == "center") 
                ctx.fillText(text, width/2 - w/2, lines[j].y);
            else
                ctx.fillText(text, width - margin - w, lines[j].y);
        }
      }
      if (preview)
        return null;
      if (i%10==0) await sleep(1); // refresh
      i++;
      var myImageData = new Uint32Array(ctx.getImageData(0, 0, width, height).data.buffer);
      var vp8 = await getVP8(canvas.width,canvas.height,myImageData);
      var frame = getANMF(width, height, frameTime, vp8);
      frames.push( frame );
      framesLength += frame.length;
      t++;
  }
  var header = makeWebpHeader(framesLength, canvas.width, canvas.height, getColorNum("back"));
  output = [header, frames];
  document.getElementById("download").hidden = false;
}

function enableButtons(v) {
   document.getElementById("go").disabled = !v;
   document.getElementById("preview").disabled = !v;
   if (!v)
    document.getElementById("download").hidden = true;
}

function run(preview) {
    enableButtons(false);
    generate(preview).then(
        function() {
            enableButtons(true);
        }
    )
    .catch(err => { console.log(err); enableButtons(true); });
    return false;
}

function changedLineOption(line) {
    var v = document.getElementById("line"+line).value;
    document.getElementById("static"+line).hidden = v != "static";
    document.getElementById("timed"+line).hidden = v != "timedtext";
}
</script>    
    </body>
</html>
