<html>
<title>Timer Generator</title>
<body>
<h1>Timer Generator</h1>
<canvas id="myCanvas" width="400" height="200"></canvas>

<script src="https://cdn.jsdelivr.net/gh/sumimakito/webpxmux.js@master/dist/webpxmux.min.js" type="text/javascript"></script>
    
<script>
var xMux = WebPXMux("https://cdn.jsdelivr.net/gh/sumimakito/webpxmux.js@master/dist/webpxmux.wasm");
xMux.waitRuntime().then(function () {
go(xMux);
}); 

function downloadBlob(name,blob) {
    var link = document.createElement('a');
    document.body.appendChild(link);
    link.download = name;
    link.href = window.URL.createObjectURL(blob);
    link.onclick = function(e) {
        setTimeout(function() {
            window.URL.revokeObjectURL(link.href);
        }, 1600);
    };
    link.click();
    try {
        link.remove();
    }
    catch(err) {}  
    try {
        document.body.removeChild(link);
    }
    catch(err) {}
}

function fix32(data) {
  for (var i=0;i<data.length;i++) {
    // in:abgr??
    r = data[i] & 0xFF;
    g = (data[i]>>8) & 0xFF;
    b = (data[i]>>16) & 0xFF;
    a = (data[i]>>24) & 0xFF;
    // out:rgba
    data[i] = (r<<24)|(g<<16)|(b<<8)|a;
  }
}

function fourCC(s) {
    return s.charCodeAt(0) | (s.charCodeAt(1) << 8) | (s.charCodeAt(2) << 16) | (s.charCodeAt(3) << 24);
}

function read32(data,offset) {
    return data[offset] | (data[offset+1]<<8) | (data[offset+2]<<16) | (data[offset+3]<<24);
}

function roundup(pos) {
    if (pos % 2)
        return pos + 1;
    else
        return pos;
}

function skipChunk(data,offset) {
    return roundup(offset + 8 + read32(data,offset+4));
}

function riffChunk(riffFile,chunkID) {
    length = 8 + read32(riffFile, 4);
    pos = 12;
    while (pos + 8 < length) {
        if (read32(riffFile, pos) == chunkID) {
            chunkLen = read32(riffFile, pos + 4);
            console.log("found");
            return riffFile.slice(pos, pos + 8 + chunkLen);
        }
        pos = skipChunk(data,pos);
    }
    return null;
}

async function getVP8(width,height,imageData) {
    fix32(imageData);
    return riffChunk(await xMux.encodeWebP({width:width,height:height,rgba:imageData}), fourCC('VP8 '));
}

function set32(data,offset,value) {
    data[offset] = value;
    data[offset+1] = value >> 8;
    data[offset+2] = value >> 16;
    data[offset+3] = value >> 24;
}

function set24(data,offset,value) {
    data[offset] = value;
    data[offset+1] = value >> 8;
    data[offset+2] = value >> 16;
}

function set16(data,offset,value) {
    data[offset] = value;
    data[offset+1] = value >> 8;
}

function getANMF(width,height,duration,vp8Chunk) {
    length = 24 + vp8Chunk.length;
    data = new Uint8Array(roundup(length));
    set32(data,0,fourCC('ANMF'));
    set32(data,4,length-8);
    set24(data,8,0);  // X
    set24(data,11,0); // Y
    set24(data,14,width-1);
    set24(data,17,height-1);
    set24(data,20,duration);
    data[23] = 0x80|0x40; // disposal:1, blend:1
    for (var i=0;i<vp8Chunk.length; i++)
        data[24+i] = vp8Chunk[i];
    return data;
}

function getWebp(width,height,bgColor,frames) {
    fileSize = 12 /* file header */ + 18 /* VP8X */ + 14 /* ANIM */;
    for (var i = 0 ; i < frames.length ; i++) {
        fileSize += 6*4 + 8 + roundup(frames[i].length);
    }
    console.log(fileSize);
    var webp = new Uint8Array(fileSize);
    set32(webp, 0, fourCC('RIFF'));
    set32(webp, 4, fileSize - 8);
    set32(webp, 8, fourCC('WEBP'));
    pos = 12; // VP8X
    set32(webp, pos, fourCC('VP8X'));
    set32(webp, pos+4, 18-8);
    webp[pos+8] = (0x10*0) /* ALPHA */ | 0x2 /* ANIMATION */;
    set24(webp, pos+8+4, width-1);
    set24(webp, pos+8+4+3, height-1);
    pos += 8 + 4 + 3 + 3;
    set32(webp, pos, fourCC('ANIM'));
    set32(webp, pos+4, 14-8);
    set32(webp, pos+8, bgColor);
    set16(webp, pos+8+4, 1); // loop count
    pos += 14;
    for (var i = 0 ; i < frames.length ; i++) {
        for (var j = 0 ; j < frames[i].length ; j++) {
            webp[pos] = frames[i][j];
            pos++;
        }
        if (pos % 2)
            pos++;        
    }
    return webp;
}

async function generateVP8s(xMux) {
  frames = [];
  var canvas = document.getElementById("myCanvas");  
  var ctx = canvas.getContext("2d", { willReadFrequently: true });
  var count = 10;
  var frameTime = 100; // milliseconds
  for (var i=0;i<count;i++) {
      ctx.fillStyle = "#E0E0E0FF";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.font = "30px Arial";
      ctx.fillStyle = "#000080FF";
      ctx.fillText("Frame "+i,0,canvas.height-10);
      var myImageData = new Uint32Array(ctx.getImageData(0, 0, canvas.width, canvas.height).data.buffer);
      var vp8 = await getVP8(canvas.width,canvas.height,myImageData);
      frames.push(getANMF(canvas.width, canvas.height, frameTime, vp8));
  }
  console.log("making webp");
  return getWebp(canvas.width, canvas.height, 0x000000FF/* bgColor */, frames);
}

function go(xMux) {
    generateVP8s(xMux).then(
        function(out) {
            console.log(out);
            downloadBlob("anim.webp",new Blob([out]));
        }
    );
/*
    var reader = new FileReader();
    reader.onload = function () {
      var data = new Uint8Array(reader.result);
      xMux.decodeFrames(data).then(function (frames) {
        console.log(frames);
        encoded = xMux.encodeFrames(frames);
        console.log(encoded);
      });
    };
    fetch("nyan.webp").then(r => r.blob() )
    .then(r => reader.readAsArrayBuffer(r));
*/
//  batch = { frameCount:1, width:canvas.width, height:canvas.height, loopCount:1, bgColor:255, frames: [frames[0]] };
//  xMux.encodeFrames(batch).then(function(r) {
//    downloadBlob("1.webp",new Blob([r]));
//    }
//  );
}
</script>    
    </body>
</html>
