<html>
<title>Timer Generator</title>
<body>
<h1>Timer Generator</h1>

<form onSubmit="return run();">
<label for="font">Font:</label>
<select name="font" id="font">
  <option value="Andalé Mono">Andalé Mono</option>
  <option value="Arial Black">Arial Black</option>
  <option value="Baskerville">Baskerville</option>
  <option value="Bradley Hand">Bradley Hand</option>
  <option value="Brush Script MT">Brush Script MT</option>
  <option value="Comic Sans MS">Comic Sans MS</option>
  <option value="Courier">Courier</option>
  <option value="Georgia">Georgia</option>
  <option value="Gill Sans">Gill Sans</option>
  <option value="Helvetica" selected>Helvetica</option>
  <option value="Impact">Impact</option>
  <option value="Lucida">Lucida</option>
  <option value="Luminari">Luminari</option>
  <option value="Monaco">Monaco</option>
  <option value="Palatino">Palatino</option>
  <option value="Tahoma">Tahoma</option>
  <option value="Times New Roman">Times New Roman</option>
  <option value="Trebuchet MS">Trebuchet MS</option>
  <option value="Verdana">Verdana</option>
</select>
<label for="size">Size:</label>
<input type="number" id="size" min="4" max="100" value="30"/>
<br/>
<label for="start">Start:</label>
<input type="text" id="start" value="00:00.0"/>
<br/>
<label for="end">End:</label>
<input type="text" id="end" value="01:00.0"/>
<br/>
<button type="submit" disabled="true" id="go">Go!</button>

</form>

<canvas id="myCanvas" width="400" height="200"></canvas>

<script src="https://cdn.jsdelivr.net/gh/sumimakito/webpxmux.js@master/dist/webpxmux.min.js" type="text/javascript"></script>
    
<script>
var xMux = WebPXMux("https://cdn.jsdelivr.net/gh/sumimakito/webpxmux.js@master/dist/webpxmux.wasm");
    xMux.waitRuntime().then(function () {
    document.getElementById("go").disabled = false;
    }); 

    
function downloadBlob(name,blob) {
    var link = document.createElement('a');
    document.body.appendChild(link);
    link.download = name;
    link.href = window.URL.createObjectURL(blob);
    link.onclick = function(e) {
        setTimeout(function() {
            window.URL.revokeObjectURL(link.href);
        }, 1600);
    };
    link.click();
    try {
        link.remove();
    }
    catch(err) {}  
    try {
        document.body.removeChild(link);
    }
    catch(err) {}
}

function fix32(data) {
  for (var i=0;i<data.length;i++) {
    // in:abgr??
    r = data[i] & 0xFF;
    g = (data[i]>>8) & 0xFF;
    b = (data[i]>>16) & 0xFF;
    a = (data[i]>>24) & 0xFF;
    // out:rgba
    data[i] = (r<<24)|(g<<16)|(b<<8)|a;
  }
}

function fourCC(s) {
    return s.charCodeAt(0) | (s.charCodeAt(1) << 8) | (s.charCodeAt(2) << 16) | (s.charCodeAt(3) << 24);
}

function read32(data,offset) {
    return data[offset] | (data[offset+1]<<8) | (data[offset+2]<<16) | (data[offset+3]<<24);
}

function roundup(pos) {
    if (pos % 2)
        return pos + 1;
    else
        return pos;
}

function skipChunk(data,offset) {
    return roundup(offset + 8 + read32(data,offset+4));
}

function riffChunk(riffFile,chunkID) {
    length = 8 + read32(riffFile, 4);
    pos = 12;
    while (pos + 8 < length) {
        if (read32(riffFile, pos) == chunkID) {
            chunkLen = read32(riffFile, pos + 4);
            return riffFile.subarray(pos, pos + 8 + chunkLen);
        }
        pos = skipChunk(data,pos);
    }
    return null;
}

async function getVP8(width,height,imageData) {
    fix32(imageData);
    return riffChunk(await xMux.encodeWebP({width:width,height:height,rgba:imageData}), fourCC('VP8 '));
}

function set32(data,offset,value) {
    data[offset] = value;
    data[offset+1] = value >> 8;
    data[offset+2] = value >> 16;
    data[offset+3] = value >> 24;
}

function set24(data,offset,value) {
    data[offset] = value;
    data[offset+1] = value >> 8;
    data[offset+2] = value >> 16;
}

function set16(data,offset,value) {
    data[offset] = value;
    data[offset+1] = value >> 8;
}

function putANMF(data,offset,width,height,duration,vp8Chunk) {
    length = 24 + vp8Chunk.length;
    if (offset + length > data.length)
        return -1;
    set32(data,offset+0,fourCC('ANMF'));
    set32(data,offset+4,length-8);
    set24(data,offset+8,0);  // X
    set24(data,offset+11,0); // Y
    set24(data,offset+14,width-1);
    set24(data,offset+17,height-1);
    set24(data,offset+20,duration);
    data[offset+23] = 0x80|0x40; // disposal:1, blend:1
    for (var i=0;i<vp8Chunk.length; i++)
        data[offset+24+i] = vp8Chunk[i];
    return roundup(length);
}

function makeWebp(webp,fileSize,width,height,bgColor) {
    set32(webp, 0, fourCC('RIFF'));
    set32(webp, 4, fileSize - 8);
    set32(webp, 8, fourCC('WEBP'));
    pos = 12; // VP8X
    set32(webp, pos, fourCC('VP8X'));
    set32(webp, pos+4, 18-8);
    webp[pos+8] = (0x10*0) /* ALPHA */ | 0x2 /* ANIMATION */;
    set24(webp, pos+8+4, width-1);
    set24(webp, pos+8+4+3, height-1);
    pos += 8 + 4 + 3 + 3;
    set32(webp, pos, fourCC('ANIM'));
    set32(webp, pos+4, 14-8);
    set32(webp, pos+8, bgColor);
    set16(webp, pos+8+4, 1); // loop count
}

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function parseTime(s) {
    var sign = 1;
    if (s[0] == '-') {
        sign = -1;
        s = s.substr(1);
    }
    var v = s.split(":");
    if (v.length == 1) {
        return sign * parseFloat(v[0]);
    }
    else if (v.length == 2) {
        return sign * (parseInt(v[0]) * 60 + parseFloat(v[1]));
    }
    else if (v.length == 3) {
        return sign * (parseInt(v[0]) * 3600 + parseInt(v[0]) * 60 + parseFloat(v[1]));
    }
    else {
        return 0;
    }
}

function formatTime(t) {
    var neg = false;
    if (t<0) {
        neg = true;
        t = -t;
    }
//    h = Math.floor(t / 3600);
//    t -= h * 3600;
    t += .00001; // a bit of rounding? TODO
    m = Math.floor(t / 60);
    t -= m * 60;
    s = Math.floor(t);
    tenths = Math.floor( (t % 1) * 10 );
    return (neg ? "-" : "") + m.toString().padStart(2, "0") + ":" + s.toString().padStart(2, "0") + "." + tenths.toString();
}

async function generateVP8s() {
  var buffer = new Uint8Array(1024*1024*1024);
  var bufferPos = 12 /* file header */ + 18 /* VP8X */ + 14 /* ANIM */;
  
  var canvas = document.getElementById("myCanvas");  
  var ctx = canvas.getContext("2d", { willReadFrequently: true });
  var frameTime = 100; // milliseconds
  var font = ""+document.getElementById("size").value+"px " + document.getElementById("font").value;
  var start = parseTime(document.getElementById("start").value);
  var end = parseTime(document.getElementById("end").value);
  
  var m = ctx.measureText(formatTime(start));
  var width = m.width;
  var height = m.fontBoundingBoxAscent + m.fontBoundingBoxDescent;
  ctx.font = font;
  m = ctx.measureText(formatTime(end));
  console.log(m);
  width = Math.max(m.width,width);
  height = Math.max(m.fontBoundingBoxAscent + m.fontBoundingBoxDescent,height);
  margin = Math.floor(0.1 * height);
  var y = height - m.fontBoundingBoxDescent;
  width = Math.floor(width + 2 * margin);
  height = Math.floor(height + 2 * margin);
  canvas.width = width;
  canvas.height = height;
  console.log(width,height);
  ctx = canvas.getContext("2d", { willReadFrequently: true });
  ctx.font = font;
  
  var t = start;
  var i = 0;
  while (t <= end + 0.00001) {
      ctx.fillStyle = "#E0E0E0FF";
      ctx.fillRect(0, 0, width, height);
      ctx.fillStyle = "#000080FF";
      console.log(t);
      ctx.font = font;
      ctx.fillText(formatTime(t),margin,y);
//      ctx.fillText("Frame "+i,0,canvas.height-10);
      if (i%10==0) await sleep(1); // refresh
      i++;
      var myImageData = new Uint32Array(ctx.getImageData(0, 0, width, height).data.buffer);
      var vp8 = await getVP8(canvas.width,canvas.height,myImageData);
      var length = putANMF(buffer, bufferPos, width, height, frameTime, vp8);
      if (length < 0)
        break;
      bufferPos += length;
      t += frameTime / 1000.;
  }
  makeWebp(buffer, bufferPos, canvas.width, canvas.height, 0x000000FF/* bgColor */);
  return buffer.subarray(0,bufferPos);
}

function run() {
    document.getElementById("go").disabled = true;
    generateVP8s().then(
        function(out) {
            downloadBlob("anim.webp",new Blob([out]));
            document.getElementById("go").disabled = false;
        }
    );
    return false;
/*
    var reader = new FileReader();
    reader.onload = function () {
      var data = new Uint8Array(reader.result);
      xMux.decodeFrames(data).then(function (frames) {
        console.log(frames);
        encoded = xMux.encodeFrames(frames);
        console.log(encoded);
      });
    };
    fetch("nyan.webp").then(r => r.blob() )
    .then(r => reader.readAsArrayBuffer(r));
*/
//  batch = { frameCount:1, width:canvas.width, height:canvas.height, loopCount:1, bgColor:255, frames: [frames[0]] };
//  xMux.encodeFrames(batch).then(function(r) {
//    downloadBlob("1.webp",new Blob([r]));
//    }
//  );
}
</script>    
    </body>
</html>
