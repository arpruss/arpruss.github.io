<html>
<title>Timer Video Generator</title>
<body>
<h1>Timer Video Generator (WEBP Animation)</h1>

<form onSubmit="return run(false);">
<label for="font">Font:</label>
<select name="font" id="font">
  <option value="Andale Mono">Andale Mono</option>
  <option value="Arial Black">Arial Black</option>
  <option value="Baskerville">Baskerville</option>
  <option value="Bradley Hand">Bradley Hand</option>
  <option value="Brush Script MT">Brush Script MT</option>
  <option value="Comic Sans MS">Comic Sans MS</option>
  <option value="Courier">Courier</option>
  <option value="Georgia">Georgia</option>
  <option value="Gill Sans">Gill Sans</option>
  <option value="Helvetica" selected>Helvetica</option>
  <option value="Impact">Impact</option>
  <option value="Lucida">Lucida</option>
  <option value="Luminari">Luminari</option>
  <option value="Monaco">Monaco</option>
  <option value="Palatino">Palatino</option>
  <option value="Tahoma">Tahoma</option>
  <option value="Times New Roman">Times New Roman</option>
  <option value="Trebuchet MS">Trebuchet MS</option>
  <option value="Verdana">Verdana</option>
</select>

<label for="size">Size:</label>
<input type="number" id="size" min="4" max="400" value="30"/>
<br/>
<label for="start">Start:</label>
<input type="text" id="start" value="00:00"/>
<br/>
<label for="end">End:</label>
<input type="text" id="end" value="01:00"/>
<br/>
<input type="checkbox" id="tenths" checked/>
<label for="tenths">Show tenths of a second</id>
<br/>
<label for="line0">Line 1:</label>
<select name="line0" id="line0" onchange="changedLineOption(0)">
  <option value="static">Static text</option>
  <option value="timer" selected>Timer</option>
  <option value="timedtext">Timed text</option>
</select>
<br/>
<input type="text" id="static0" value="" placeholder="Static text" hidden="true"/>
<textarea id="timed0" name="text" rows="10" cols="60" placeholder="00:00 Start" hidden="true"></textarea>
<br/>
<label for="line1">Line 2:</label>
<select name="line1" id="line1" onchange="changedLineOption(1)">
  <option value="none" selected>None</option>
  <option value="static">Static text</option>
  <option value="timer">Timer</option>
  <option value="timedtext">Timed text</option>
</select>
<br/>
<input type="text" id="static1" value="" placeholder="Static text" hidden="true"/>
<textarea id="timed1" name="text" rows="10" cols="60" placeholder="00:00 Start" hidden="true" ></textarea>
<br/>
<button type="button" disabled="true" id="preview" onClick="run(true);">Preview</button>
<button type="submit" disabled="true" id="go">Go!</button>

</form>
<br/>
<br/>

<canvas id="myCanvas" width="400" height="200"></canvas>

<script src="https://cdn.jsdelivr.net/gh/sumimakito/webpxmux.js@master/dist/webpxmux.min.js" type="text/javascript"></script>
    
<script>
var xMux = WebPXMux("https://cdn.jsdelivr.net/gh/sumimakito/webpxmux.js@master/dist/webpxmux.wasm");
    xMux.waitRuntime().then(function () {
    document.getElementById("go").disabled = false;
    document.getElementById("preview").disabled = false;
    }); 

    
function downloadBlob(name,blob) {
    var link = document.createElement('a');
    document.body.appendChild(link);
    link.download = name;
    link.href = window.URL.createObjectURL(blob);
    link.onclick = function(e) {
        setTimeout(function() {
            window.URL.revokeObjectURL(link.href);
        }, 1600);
    };
    link.click();
    try {
        link.remove();
    }
    catch(err) {}  
    try {
        document.body.removeChild(link);
    }
    catch(err) {}
}

function fix32(data) {
  for (var i=0;i<data.length;i++) {
    // in:abgr??
    r = data[i] & 0xFF;
    g = (data[i]>>8) & 0xFF;
    b = (data[i]>>16) & 0xFF;
    a = (data[i]>>24) & 0xFF;
    // out:rgba
    data[i] = (r<<24)|(g<<16)|(b<<8)|a;
  }
}

function fourCC(s) {
    return s.charCodeAt(0) | (s.charCodeAt(1) << 8) | (s.charCodeAt(2) << 16) | (s.charCodeAt(3) << 24);
}

function read32(data,offset) {
    return data[offset] | (data[offset+1]<<8) | (data[offset+2]<<16) | (data[offset+3]<<24);
}

function roundup(pos) {
    if (pos % 2)
        return pos + 1;
    else
        return pos;
}

function skipChunk(data,offset) {
    return roundup(offset + 8 + read32(data,offset+4));
}

function riffChunk(riffFile,chunkID) {
    length = 8 + read32(riffFile, 4);
    pos = 12;
    while (pos + 8 < length) {
        if (read32(riffFile, pos) == chunkID) {
            chunkLen = read32(riffFile, pos + 4);
            return riffFile.subarray(pos, pos + 8 + chunkLen);
        }
        pos = skipChunk(data,pos);
    }
    return null;
}

async function getVP8(width,height,imageData) {
    fix32(imageData);
    return riffChunk(await xMux.encodeWebP({width:width,height:height,rgba:imageData}), fourCC('VP8 '));
}

function set32(data,offset,value) {
    data[offset] = value;
    data[offset+1] = value >> 8;
    data[offset+2] = value >> 16;
    data[offset+3] = value >> 24;
}

function set24(data,offset,value) {
    data[offset] = value;
    data[offset+1] = value >> 8;
    data[offset+2] = value >> 16;
}

function set16(data,offset,value) {
    data[offset] = value;
    data[offset+1] = value >> 8;
}

function putANMF(data,offset,width,height,duration,vp8Chunk) {
    length = 24 + vp8Chunk.length;
    if (offset + length > data.length)
        return -1;
    set32(data,offset+0,fourCC('ANMF'));
    set32(data,offset+4,length-8);
    set24(data,offset+8,0);  // X
    set24(data,offset+11,0); // Y
    set24(data,offset+14,width-1);
    set24(data,offset+17,height-1);
    set24(data,offset+20,duration);
    data[offset+23] = 0x80|0x40; // disposal:1, blend:1
    for (var i=0;i<vp8Chunk.length; i++)
        data[offset+24+i] = vp8Chunk[i];
    return roundup(length);
}

function makeWebp(webp,fileSize,width,height,bgColor) {
    set32(webp, 0, fourCC('RIFF'));
    set32(webp, 4, fileSize - 8);
    set32(webp, 8, fourCC('WEBP'));
    pos = 12; // VP8X
    set32(webp, pos, fourCC('VP8X'));
    set32(webp, pos+4, 18-8);
    webp[pos+8] = (0x10*0) /* ALPHA */ | 0x2 /* ANIMATION */;
    set24(webp, pos+8+4, width-1);
    set24(webp, pos+8+4+3, height-1);
    pos += 8 + 4 + 3 + 3;
    set32(webp, pos, fourCC('ANIM'));
    set32(webp, pos+4, 14-8);
    set32(webp, pos+8, bgColor);
    set16(webp, pos+8+4, 1); // loop count
}

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function parseTime(s,tenths) {
    var sign = 1;
    if (s[0] == '-') {
        sign = -1;
        s = s.substr(1);
    }
    
    var t = 0;
    var mul = 1;

    var x = s.split(".");
    if (tenths) {
        if (x.length > 1)
            t = parseInt(x[1][0]);
        mul = 10;
    }
    
    var v = x[0].split(":");
    for (var i = v.length - 1 ; i >= 0 ; i--) {
        t += mul * parseInt(v[i]);
        mul *= 60;
    }
    return sign * t;
}

function formatTime(t, tenths) {
    var neg = false;
    if (t<0) {
        neg = true;
        t = -t;
    }
    var decimal = "";
    if (tenths) {
        decimal = "."+(t%10).toString();
        t = (t/10) >> 0;
    }
    s = t % 60;
    m = ( (t / 60) >> 0 );
//    h = (t / 3600) >> 0;
    return (neg ? "-" : "") + m.toString().padStart(2, "0") + ":" + s.toString().padStart(2, "0") + decimal;
}

async function generate(preview) {
  const tenths = document.getElementById("tenths").checked;
  const frameTime = tenths ? 100 : 1000; // milliseconds
  var canvas = document.getElementById("myCanvas");  
  var ctx = canvas.getContext("2d", { willReadFrequently: true });
  var font = ""+document.getElementById("size").value+"px " + document.getElementById("font").value;
  var start = parseTime(document.getElementById("start").value, tenths);
  var end = parseTime(document.getElementById("end").value, tenths);
  
  var m = ctx.measureText(formatTime(start, tenths));
  var width = m.width;
  var height = m.fontBoundingBoxAscent + m.fontBoundingBoxDescent;
  ctx.font = font;
  m = ctx.measureText(formatTime(end, tenths));
  console.log(m);
  width = Math.max(m.width,width);
  height = Math.max(m.fontBoundingBoxAscent + m.fontBoundingBoxDescent,height);
  margin = Math.floor(0.1 * height);
  var y = height - m.fontBoundingBoxDescent;
  width = Math.floor(width + 2 * margin);
  height = Math.floor(height + 2 * margin);
  canvas.width = width;
  canvas.height = height;
  console.log(width,height);
  ctx = canvas.getContext("2d", { willReadFrequently: true });
  ctx.font = font;

  var buffer;
  var bufferPos
  
  if (! preview) {
      var buffer = new Uint8Array(1024*1024*1024);
      var bufferPos = 12 /* file header */ + 18 /* VP8X */ + 14 /* ANIM */;
  }
  
  var t = preview ? ((end + start)/2)>>0 : start;
  var i = 0;
  while (t <= end) {
      ctx.fillStyle = "#E0E0E0FF";
      ctx.fillRect(0, 0, width, height);
      ctx.fillStyle = "#000080FF";
      console.log(t);
      ctx.font = font;
      ctx.fillText(formatTime(t, tenths),margin,y);
      if (preview)
        return true;
      if (i%10==0) await sleep(1); // refresh
      i++;
      var myImageData = new Uint32Array(ctx.getImageData(0, 0, width, height).data.buffer);
      var vp8 = await getVP8(canvas.width,canvas.height,myImageData);
      var length = putANMF(buffer, bufferPos, width, height, frameTime, vp8);
      if (length < 0)
        break;
      bufferPos += length;
      t++;
  }
  makeWebp(buffer, bufferPos, canvas.width, canvas.height, 0x000000FF/* bgColor */);
  return buffer.subarray(0,bufferPos);
}

function run(preview) {
    document.getElementById("go").disabled = true;
    document.getElementById("preview").disabled = true;
    generate(preview).then(
        function(out) {
            if (! preview) 
                downloadBlob("anim.webp",new Blob([out]));
            document.getElementById("go").disabled = false;
            document.getElementById("preview").disabled = false;
        }
    );
    return false;
/*
    var reader = new FileReader();
    reader.onload = function () {
      var data = new Uint8Array(reader.result);
      xMux.decodeFrames(data).then(function (frames) {
        console.log(frames);
        encoded = xMux.encodeFrames(frames);
        console.log(encoded);
      });
    };
    fetch("nyan.webp").then(r => r.blob() )
    .then(r => reader.readAsArrayBuffer(r));
*/
//  batch = { frameCount:1, width:canvas.width, height:canvas.height, loopCount:1, bgColor:255, frames: [frames[0]] };
//  xMux.encodeFrames(batch).then(function(r) {
//    downloadBlob("1.webp",new Blob([r]));
//    }
//  );
}

function changedLineOption(line) {
    var v = document.getElementById("line"+line).value;
    document.getElementById("static"+line).hidden = v != "static";
    document.getElementById("timed"+line).hidden = v != "timedtext";
}
</script>    
    </body>
</html>
