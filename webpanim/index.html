<html>
<title>Timer and Text Video Generator</title>
<!-- MIT License -->
<body>
<h1>Timer and Text Video WebP Animation Generator</h1>

<form>
<label for="line0">Line 1:</label>
<select name="line0" id="line0" onchange="changedLineOption(0)">
  <option value="S.x">S.x</option>
  <option value="SS.x">SS.x</option>
  <option value="M:ss.x">M:ss.x</option>
  <option value="MM:ss.x" selected>MM:ss.x</option>
  <option value="H:mm:ss.x">H:mm:ss.x</option>
  <option value="S">S</option>
  <option value="SS">SS</option>
  <option value="M:ss">M:ss</option>
  <option value="MM:ss">MM:ss</option>
  <option value="H:mm:ss">H:mm:ss</option>
  <option value="static">Static text</option>
  <option value="timedtext">Timed text</option>
</select>
<br/>
<input type="text" id="static0" value="" placeholder="Static text" hidden="true"/>
<textarea id="timed0" name="text" rows="10" cols="60" placeholder="00:00 Start" hidden="true"></textarea>
<br/>
<label for="line1">Line 2:</label>
<select name="line1" id="line1" onchange="changedLineOption(1)">
  <option value="none" selected>None</option>
  <option value="S.x">S.x</option>
  <option value="SS.x">SS.x</option>
  <option value="M:ss.x">M:ss.x</option>
  <option value="MM:ss.x">MM:ss.x</option>
  <option value="H:mm:ss.x">H:mm:ss.x</option>
  <option value="S">S</option>
  <option value="SS">SS</option>
  <option value="M:ss">M:ss</option>
  <option value="MM:ss">MM:ss</option>
  <option value="H:mm:ss">H:mm:ss</option>
  <option value="static">Static text</option>
  <option value="timedtext">Timed text</option>
</select>
<br/>
<input type="text" id="static1" value="" placeholder="Static text" hidden="true"/>
<textarea id="timed1" name="text" rows="10" cols="60" placeholder="00:00 Start" hidden="true" ></textarea>
<br/>

<table>
<tr>
<td>
<label for="start">Start:</label>
</td>
<td>
<input type="text" id="start" value="00:00"/>
</td>
</tr>
<tr>
<td>
<label for="end">End:</label>
</td>
<td>
<input type="text" id="end" value="01:00"/>
</td>
</tr>
<tr>
<td>
<label for="font">Font:</label>
</td>
<td>
<select name="font" id="font" onchange="changedFont()">
  <option value="Hershey Sans">Hershey Sans</option>
  <option value="Hershey SansBold">Hershey Sans Bold</option>
  <option value="Hershey SansBoldOblique">Hershey Sans Bold Oblique</option>
  <option value="Hershey Serif">Hershey Serif</option>
  <option value="Hershey SerifBold">Hershey SerifBold</option>
  <option value="Hershey SerifItalic">Hershey SerifItalic</option>
  <option value="Andale Mono">Andale Mono</option>
  <option value="Arial" selected>Arial</option>
  <option value="Arial Black">Arial Black</option>
  <option value="Baskerville">Baskerville</option>
  <option value="Bradley Hand">Bradley Hand</option>
  <option value="Brush Script MT">Brush Script MT</option>
  <option value="Comic Sans MS">Comic Sans MS</option>
  <option value="Courier">Courier</option>
  <option value="Georgia">Georgia</option>
  <option value="Gill Sans">Gill Sans</option>
  <option value="Helvetica">Helvetica</option>
  <option value="Impact">Impact</option>
  <option value="Lucida">Lucida</option>
  <option value="Luminari">Luminari</option>
  <option value="Monaco">Monaco</option>
  <option value="Palatino">Palatino</option>
  <option value="Tahoma">Tahoma</option>
  <option value="Times New Roman">Times New Roman</option>
  <option value="Trebuchet MS">Trebuchet MS</option>
  <option value="Verdana">Verdana</option>
</select>
</td>
</tr>
<tr id="hersheyThickness" hidden="true">
<td>
<label for="thickness">Thickness:</label>
</td>
<td>
<input type="number" id="thickness" min="1" max="8" value="3" size="4"/>
</td>
</tr>
<tr>
<td>
<label for="size">Size:</label>
</td>
<td>
<input type="number" id="size" min="4" max="400" value="30" size="4"/>
</td>
</tr>
<tr>
<td>
Text:
</td>
<td>
<label for="textR">Red</label> <input id = "textR" type="number" min="0" max="255" size="4" value="0"/>
<label for="textG">Green</label> <input id = "textG" type="number" min="0" max="255" size="4" value="0"/>
<label for="textB">Blue</label> <input id = "textB" type="number" min="0" max="255" size="4" value="128"/>
<label for="textA">Opacity</label> <input id = "textA" type="number" min="0" max="1" size="4" value="1" step="0.05"/>
</td>
</tr> 
<tr>
<td>
Back:
</td> 
<td>
<label for="backR">Red</label> <input id = "backR" type="number" min="0" max="255" size="4" value="0"/>
<label for="backG">Green</label> <input id = "backG" type="number" min="0" max="255" size="4" value="0"/>
<label for="backB">Blue</label> <input id = "backB" type="number" min="0" max="255" size="4" value="0"/>
<label for="backA">Opacity</label> <input id = "backA" type="number" min="0" max="1" size="4" value="0.5" step="0.05"/>
</td>
</tr>
<tr>
<td>
<label for="margin">Margin:</label>
</td>
<td>
<input type="number" min="0" max="2" value="0.1" step="0.05" size="4" id="margin"/>
</td>
</tr>

<tr>
<td>
<label for="margin">Rounding:</label>
</td>
<td>
<input type="number" min="0" max="1" value="0" step="0.1" size="4" id="rounding"/>
</td>
</tr>


<tr>
<td>
<label for="align">Align:</label>
</td>
<td>
<select name="align" id="align">
  <option value="left">Left</option>
  <option value="right">Right</option>
  <option value="center" selected>Center</option>
</select>
</td>
</tr>
</table>
<br/>
<button type="button" disabled="true" id="preview" onClick="run(true);">Preview</button>
<button type="button" disabled="true" id="go" onClick="run(false);">Generate!</button>
<br/>
<div id="downloadpara" hidden="true"><button type="button" id="download" onClick="downloadToDisc(output)">Download WebP file</button><div id="downloadtext"></div></div>
</form>
<br/>

<canvas id="myCanvas" width="400" height="200"></canvas>
<script src="https://cdn.jsdelivr.net/gh/sumimakito/webpxmux.js@master/dist/webpxmux.min.js" type="text/javascript"></script>
<script src="./hershey.js" type="text/javascript"></script>
<script>

var output = null;
var countDown = false;

var xMux = WebPXMux("https://cdn.jsdelivr.net/gh/sumimakito/webpxmux.js@master/dist/webpxmux.wasm");
    xMux.waitRuntime().then(function () {
    enableButtons(true);
    }); 

async function downloadToDisc(output) {
    const opts = {
        types: [{
          description: 'WebP animation',
          accept: {'image/webp': ['.webp']},
        }],
    };
    
    if (window.showSaveFilePicker) {
        const newHandle = await window.showSaveFilePicker(opts);

        const writableStream = await newHandle.createWritable();
        
        for (var i = 0 ; i < output.length ; i++) {
            await writableStream.write(new Blob([output[i]]));
        }

        await writableStream.close();
        
        const d = document.getElementById("downloadtext");
        if (d.textContent.indexOf("(") < 0)
            d.textContent += " (saved!)";

    }
    else {
        downloadBlob("animation.webp", new Blob(output));
    }
}
    
function downloadBlob(name,blob) {
    var link = document.createElement('a');
    document.body.appendChild(link);
    link.download = name;
    link.href = window.URL.createObjectURL(blob);
    link.onclick = function(e) {
        setTimeout(function() {
            window.URL.revokeObjectURL(link.href);
        }, 1600);
    };
    link.click();
    try {
        link.remove();
    }
    catch(err) {}  
    try {
        document.body.removeChild(link);
    }
    catch(err) {}
}

function fix32(data) {
  for (var i=0;i<data.length;i++) {
    // in:abgr
    r = data[i] & 0xFF;
    g = (data[i]>>8) & 0xFF;
    b = (data[i]>>16) & 0xFF;
    a = (data[i]>>24) & 0xFF;
    // out:rgba
    data[i] = (r<<24)|(g<<16)|(b<<8)|a;
  }
}

function fourCC(s) {
    return s.charCodeAt(0) | (s.charCodeAt(1) << 8) | (s.charCodeAt(2) << 16) | (s.charCodeAt(3) << 24);
}

function read32(data,offset) {
    return data[offset] | (data[offset+1]<<8) | (data[offset+2]<<16) | (data[offset+3]<<24);
}

function roundup(pos) {
    if (pos % 2)
        return pos + 1;
    else
        return pos;
}

function skipChunk(data,offset) {
    return roundup(offset + 8 + read32(data,offset+4));
}

function riffChunk(riffFile,chunkID) {
    length = 8 + read32(riffFile, 4);
    pos = 12;
    while (pos + 8 < length) {
        if (read32(riffFile, pos) == chunkID) {
            chunkLen = read32(riffFile, pos + 4);
            return riffFile.subarray(pos, pos + 8 + roundup(chunkLen));
        }
        pos = skipChunk(riffFile,pos);
    }
    return null;
}

async function getVP8(width,height,imageData) {
    fix32(imageData);
    const encoded = await xMux.encodeWebP({width:width,height:height,rgba:imageData});
    const vp8 = riffChunk(encoded, fourCC('VP8 '));
    const alph = riffChunk(encoded, fourCC('ALPH'));
    if (! alph)
        return vp8;
    var array = new Uint8Array(vp8.length+alph.length);
    array.set(alph);
    array.set(vp8,alph.length);
    return array;
}

function set32(data,offset,value) {
    data[offset] = value;
    data[offset+1] = value >> 8;
    data[offset+2] = value >> 16;
    data[offset+3] = value >> 24;
}

function set24(data,offset,value) {
    data[offset] = value;
    data[offset+1] = value >> 8;
    data[offset+2] = value >> 16;
}

function set16(data,offset,value) {
    data[offset] = value;
    data[offset+1] = value >> 8;
}

function getANMF(width,height,duration,vp8Chunk) {
    length = 24 + vp8Chunk.length;
    data = new Uint8Array(roundup(length));
    set32(data,0,fourCC('ANMF'));
    set32(data,4,length-8);
    set24(data,8,0);  // X
    set24(data,11,0); // Y
    set24(data,14,width-1);
    set24(data,17,height-1);
    set24(data,20,duration);
    data[23] = (1*1)|(2*0); // disposal:1, blend:1
    data.set(vp8Chunk, 24);
    return data;
}

function makeWebpHeader(frameSize,width,height,bgColor) {
    var fileSize = frameSize + 12 /* file header */ + 18 /* VP8X */ + 14 /* ANIM */;
    var webp = new Uint8Array(12 /* file header */ + 18 /* VP8X */ + 14 /* ANIM */);

    set32(webp, 0, fourCC('RIFF'));
    set32(webp, 4, fileSize - 8);
    set32(webp, 8, fourCC('WEBP'));
    pos = 12; // VP8X
    set32(webp, pos, fourCC('VP8X'));
    set32(webp, pos+4, 18-8);
    webp[pos+8] = (0x10*1) /* ALPHA */ | 0x2 /* ANIMATION */;
    set24(webp, pos+8+4, width-1);
    set24(webp, pos+8+4+3, height-1);
    pos += 8 + 4 + 3 + 3;
    set32(webp, pos, fourCC('ANIM'));
    set32(webp, pos+4, 14-8);
    set32(webp, pos+8, bgColor);
    set16(webp, pos+8+4, 1); // loop count
    
    return webp;
}

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function parseTime(s) {
    var sign = 1;
    if (s[0] == '-') {
        sign = -1;
        s = s.substr(1);
    }
    
    var t = 0;
    var mul = 1000;
    const v = s.split(":");
    var last = v[v.length-1];
    var decimal = last.indexOf(".");
    if (decimal >= 0) {
        t = parseInt((last.substr(decimal+1)+"000").substr(0,3));
        v[v.length-1] = last.substr(0,decimal);
    }
    
    for (var i = v.length - 1 ; i >= 0 ; i--) {
        t += mul * parseFloat(v[i]);
        if (mul < 3600*1000) 
            mul *= 60;
        else
            mul = 86400*1000;
    }
    return sign * t;
}

function formatTime(t, format) {
    round = countDown ? Math.ceil : Math.floor;

    if (t<0) {
        return round(t / 1000).toString();
    }

    values = { x:round(t/100)%10, S:round(t/1000),
               M:round(t/60000), H:round(t/3600000), D:round(t/86400000) };
    values.s = values.S%60;
    values.m = values.M%60;
    values.h = values.H%60;
    
    out = "";
    
    for (var i=0; i<format.length; i++) {
        var f = format[i];
        var v = values[f];
        if (v !== undefined) {
            var j;
            for (j=i+1; j<format.length && format[j] == f; j++) ;
            out += v.toString().padStart(j-i, "0");
            i = j - 1;
        }
        else {
            out += f;
        }
    }
    
    return out;
}

function parseTimedText(text) {
  timedText = [];
  lines = text.split(/\r?\n/);
  for (var i = 0 ; i < lines.length ; i++) {
    var line = lines[i].trim();
    if (line) {
        var t = 0;
        var show = "";
        const found = line.match(/([^\s]*)\s+(.*)/);
        if (found) {
            t = parseTime(found[1]);
            show = found[2];
        }
        else {
            t = parseTime(line);
        }
        timedText.push( { "time": t, "text": show } );
    }
  }
  timedText.sort((a,b) => a.time - b.time);
  console.log(timedText);
  return timedText;
}

function getText(t, lineOptions) {
  if (lineOptions.mode == "none")
    return "";
  else if (lineOptions.mode == "static")
    return lineOptions.static;
  else if (lineOptions.mode == "timedtext") {
    var text = "(empty)";
    var timedText = lineOptions.timedText;
    if (countDown) {
        for (var i = timedText.length-1 ; i >= 0 ; i--) {
            if (t <= timedText[i].time) 
                text = timedText[i].text;
            else
                break;
        }
    }
    else {
        for (var i = 0 ; i < timedText.length ; i++) {
            if (t >= timedText[i].time) 
                text = timedText[i].text;
            else
                break;
        }
    }
    return text;
  }
  else {
    return formatTime(t, lineOptions.mode);
  }
}

function lineMetrics(line, font, start, end) {
    var texts;
    if (line.mode == "static") {
        texts = [ line.static ];
    }
    else if (line.mode == "timedtext") {
        texts = [];
        for (var i = 0 ; i < line.timedText.length ; i++)
            texts.push(line.timedText[i].text);
    }
    else {
        texts = [ formatTime(start, line.mode), formatTime(((start+end)/2) >> 0, line.mode), formatTime(end, line.mode) ];
    }
    var metrics = { width:0, ascent:0, descent:0 };
    for (var i = 0 ; i < texts.length ; i++) {
        var m = font.measure(texts[i]);
        metrics.width = Math.max(m.width, metrics.width);
        metrics.ascent = Math.max(m.actualBoundingBoxAscent, metrics.ascent);
        metrics.descent = Math.max(m.actualBoundingBoxDescent, metrics.descent);
    }
    metrics.height = metrics.ascent + metrics.descent;
    return metrics;
}

function getColor(elt) {
  return "rgba("+
      document.getElementById(elt + "R").value+","+
      document.getElementById(elt + "G").value+","+
      document.getElementById(elt + "B").value+","+
      document.getElementById(elt + "A").value+")";
}

function getARGB(elt) {
    return (document.getElementById(elt + "B").value) | 
      (document.getElementById(elt + "G").value<<8)|
      (document.getElementById(elt + "R").value<<16)|
      (Math.floor(255*document.getElementById(elt + "A").value)<<24);
}

function digitFixedFillText(ctx, digitWidths, text, x, y) {
    // draw text while making each digit the size of a zero
    while(text.length) {
        nextFix = text.search(/[1-9]/);
        if (nextFix < 0) {
            ctx.fillText(text, x, y);
            return;
        }
        else if (nextFix > 0) {
            var part = text.slice(0, nextFix);
            ctx.fillText(part, x, y);
            x += ctx.measureText(part).width;
            text = text.slice(nextFix);
        }
        ctx.fillText(text[0], x + (digitWidths[0]-digitWidths[parseInt(text[0])])/2, y);
        x += digitWidths[0];
        text = text.slice(1);
    }
}

function isMono(ctx) {
    const test = " .WI0123456789";
    var w = ctx.measureText(test[0]).width;
    for (var i = 1; i<test.length; i++)
        if (w != ctx.measureText(test[i]).width)
            return false;
    return true;
}

function getFont(ctx) {
    const fontName = document.getElementById("font").value;
    const fontSize = parseFloat(document.getElementById("size").value);
    var measure;
    var draw;
    var hersheyThickness = parseInt(document.getElementById("thickness").value);
    if (fontName.startsWith("Hershey ")) {
        ctx.strokeStyle = getColor("text");
        ctx.lineWidth = hersheyThickness;
        const hersheyFont = hersheyFonts[fontName.substr(8)];
        measure = ( (text) => hersheyMeasureString(hersheyFont,fontSize,text) );
        draw = ( (text,x,y) => hersheyRenderString(ctx,hersheyFont,fontSize,text,x,y) );
        
    }
    else {
        ctx.font = ""+fontSize+"px "+fontName;
        ctx.fillStyle = getColor("text");
        if (!isMono(ctx)) {
            measure = ( (text) => ctx.measureText(text.replace(/[1-9]/g,"0")) );
            var digitWidths = [];
            for (var i = 0 ; i <= 9 ; i++)
                digitWidths[i] = ctx.measureText(i.toString()).width;
            draw = ( (text,x,y) => digitFixedFillText(ctx, digitWidths, text, x, y) );
        }
        else {
            console.log("mono");
            measure = ( (text) => ctx.measureText(text) );
            draw = ( (text,x,y) => ctx.fillText(text, x, y) );
        }
    }
    return { measure:measure, draw:draw };
}

async function generate(preview) {
  output = [null];
 
  const align = document.getElementById("align").value;
  const rounding = parseFloat(document.getElementById("rounding").value);
  
  const back = getColor("back");
  
  var lines = [ {mode:document.getElementById("line0").value}, {mode:document.getElementById("line1").value} ];
  const numLines = lines[1].mode != "none" ? lines.length : 1;
  
  const canvas = document.getElementById("myCanvas");  
  var ctx = canvas.getContext("2d", { willReadFrequently: true });
  var font = getFont(ctx);
  const start = parseTime(document.getElementById("start").value);
  const end = parseTime(document.getElementById("end").value);
  
  countDown = start > end;
  
  for (var i = 0 ; i < numLines ; i++) {
    if (lines[i].mode == "timedtext")
        lines[i].timedText = parseTimedText(document.getElementById("timed"+i).value);
    else if (lines[i].mode == "static")
        lines[i].static = document.getElementById("static"+i).value;
    lines[i].metrics = lineMetrics(lines[i], font, start, end);
  }
  
  var precision = (lines[0].mode.endsWith("x") || lines[1].mode.endsWith("x")) ? 100 : 1000;
  
  if (precision == 1000) {
      for (var i=0; i<numLines ; i++) {
        var tt = lines[i].timedText;
        if (tt) {
            for (var j=0; j<numLines;j++) {
                if (tt[j].time % 1000) {
                    precision = 100;
                    i = numLines;
                    break;
                }
            }
        }
      }
  }
  
  var margin;
  var width;
  var height;
  
  var marginFrac = parseFloat(document.getElementById("margin").value);
  
  var hersheyThickness = parseInt(document.getElementById("thickness").value);
  var extraMargin = document.getElementById("font").value.startsWith("Hershey ") ? (hersheyThickness / 2)>>0 : 0;
  
  if (numLines == 1) {
    margin = extraMargin + Math.ceil(marginFrac * lines[0].metrics.height);
    width = 2 * margin + Math.ceil(lines[0].metrics.width);
    height = 2 * margin + Math.ceil(lines[0].metrics.height);
    lines[0].y = Math.floor(height - margin - lines[0].metrics.descent);
  }
  else {
    maxHeight = Math.max(lines[0].metrics.height, lines[1].metrics.height);
    margin = extraMargin + Math.ceil(marginFrac * maxHeight);
    width = 2 * margin + Math.ceil(Math.max(lines[0].metrics.width, lines[1].metrics.width));
    height = 3 * margin + Math.ceil(lines[0].metrics.height) + Math.ceil(lines[1].metrics.height);
    lines[0].y = Math.floor(margin + lines[0].metrics.height - lines[0].metrics.descent);
    lines[1].y = Math.floor(height - margin - lines[1].metrics.descent);
  }
  
  canvas.width = width;
  canvas.height = height;
  ctx = canvas.getContext("2d", { willReadFrequently: true });
  var font = getFont(ctx);

  if (! preview) {
    var framesLength = 0;
  }
  
  var t = preview ? ((end + start)/2)>>0 : start;
  var i = 0;
  while ((t <= end && ! countDown) || (end <= t && countDown)) {
      ctx.clearRect(0, 0, width, height);
      var saved = ctx.fillStyle;
      ctx.fillStyle = back;
      if (rounding) {
        ctx.beginPath();
        ctx.roundRect(0, 0, width, height, height * rounding / 2);
        ctx.fill();
      }
      else {
        ctx.fillRect(0, 0, width, height);
      }
      ctx.fillStyle = saved;
      for (var j=0; j<numLines; j++) {
        const text = getText(t, lines[j]);
        if (align == "left") {
            font.draw(text, margin, lines[j].y);
        }
        else {
            const w = font.measure(text).width;
            if (align == "center") 
                font.draw(text, width/2 - w/2, lines[j].y);
            else
                font.draw(text, width - margin - w, lines[j].y);
        }
      }
      if (preview)
        return null;
      if (i%10==0) await sleep(1); // refresh
      i++;
      var myImageData = new Uint32Array(ctx.getImageData(0, 0, width, height).data.buffer);
      var vp8 = await getVP8(width, height, myImageData);
      var frame = getANMF(width, height, precision, vp8);
      output.push( frame );
      framesLength += frame.length;
      if (countDown)
        t-=precision;
      else
        t+=precision;
  }
  output[0] = makeWebpHeader(framesLength, width, height, getARGB("back"));
  const d = document.getElementById("downloadtext");
  d.textContent = ""+(framesLength+output[0].length)+" bytes";
  document.getElementById("downloadpara").hidden = false;
}

function enableButtons(v) {
   document.getElementById("go").disabled = !v;
   document.getElementById("preview").disabled = !v;
   if (!v) {
     document.getElementById("downloadpara").hidden = true;
   }
}

function run(preview) {
    enableButtons(false);
    generate(preview).then(
        function() {
            enableButtons(true);
        }
    )
    .catch(err => { console.log(err); enableButtons(true); });
    return false;
}

function changedFont() {
    document.getElementById("hersheyThickness").hidden = ! document.getElementById("font").value.startsWith("Hershey ");
}

function changedLineOption(line) {
    var v = document.getElementById("line"+line).value;
    document.getElementById("static"+line).hidden = v != "static";
    document.getElementById("timed"+line).hidden = v != "timedtext";
}
</script>    
    </body>
</html>
